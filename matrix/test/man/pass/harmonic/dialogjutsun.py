#!/usr/bin/python

# From equations (3.78) and (3.79) we see that the matrices A and B are or-
# thogonal to each other if and only if A T B and B T A are hollow (that is, they
# have 0s in all diagonal positions). We also use the term “orthonormal” to refer
# to matrices that are orthogonal to each other and for which each has a dot
# product with itself of 1. In Section 3.7, we will deﬁne orthogonality as a unary
# property of matrices. The term “orthogonal”, when applied to matrices, gen-
# erally refers to that property rather than the binary property we have deﬁned
# here.
def orthogonal(self, x, y):
    if x != y:
       return(x * y)
    else:
      print(x, y)

orthogonal(3, 3.80, 5.80)

def orth(self, x, y):
    if x != y :
       return x * y 
    else:
      print(x, y)
orth(3, 3.85, 8.85)

# On page 48 we identiﬁed a vector space of matrices and deﬁned a basis
# for the space IR n×m . If {U 1 , . . . , U k } is a basis set for M ⊂ IR n×m 
# , with the property that U i , U j = 0 for i = j and U i , U i = 1, and A is 
# an n × m matrix, with the Fourier expansion      
M="U1",1,1,1,"Uk"
IR="Ui",1,1,1,"Uj"
if M in IR == 0:
   M
else:
  print(M)
M  

# Basic Properties of Matrices
# c i = A, U i .
# (3.83)
# The c i have the same properties (such as the Parseval identity, equation (2.38),
# for example) as the Fourier coeﬃcients in any orthonormal expansion. Best
# approximations within M can also be expressed as truncations of the sum
# in equation (3.82) as in equation (2.41). The objective of course is to reduce
# the truncation error. (The norms in Parseval’s identity and in measuring the
# goodness of an approximation are matrix norms in this case. We discuss matrix
# norms in Section 3.9 beginning on page 128.) 
ci="A","Ui"
ci

# 3.3 Matrix Rank and the Inverse of a
# Full Rank Matrix
# The linear dependence or independence of the vectors forming the rows or
# columns of a matrix is an important characteristic of the matrix.
# The maximum number of linearly independent vectors (those forming ei-
# ther the rows or the columns) is called the rank of the matrix. We use the
# notation

def jutsun(self, matrix):
    if matrix != matrix:
       matrix={'connected', 123, 'home', 123, 'rooms', 123}
    else:
      return matrix * matrix
      def foo():
        doc = "The foo property."
        def fget(self):
          return self._foo
        def fset(self, value):
          self._foo = value

foo="Ui",3.80,"Uk" 
foo
jutsun(3, matrix=3.80)

# to denote the rank of the matrix A. (We have used the term “rank” before to
# denote dimensionality of an array. “Rank” as we have just deﬁned it applies
# only to a matrix or to a set of vectors, and this is by far the more common
# meaning of the word. The meaning is clear from the context, however.)
# Because multiplication by a nonzero scalar does not change the linear
# independence of vectors, for the scalar a with a = 0, we have

def rank(self, r):
    if r:
       return r * r / r
    else: 
      r = 0
      for r in range(r, 100):
          r
      else:
        print(r)
rank(3, r=6)
      
