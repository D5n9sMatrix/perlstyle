#!/usr/bin/python

# Matrix Rank and the Inverse of a Matrix
# 77
# of the elements of each vector in a set of vectors does not change the linear
# dependencies over the set.) After these permutations, we have a matrix B
# with submatrices W , X, Y , and Z,
rank(3, 15)

# where the rows of R = [W
# |X] correspond to p linearly independent m-vectors
# W
# and the columns of C =
# correspond to q linearly independent n-vectors.
# Y
# Without loss of generality, we can assume p ≤ q. Now, if p < q, it must be
# the case that the columns of W are linearly dependent because there are q of
# them, but they have only p elements. Therefore, there is some q-vector a such
# that W a = 0. Now, since the rows of R are the full set of linearly independent
# rows, any row in [Y |Z] can be expressed as a linear combination of the rows
# of R, and any row in Y can be expressed as a linear combination of the rows
# of W . This means, for some n−p × p matrix T , that Y = T W . In this case,
# however, Ca = 0. But this contradicts the assumption that the columns of
# C are linearly independent; therefore it cannot be the case that p < q. We
# conclude therefore that p = q; that is, that the maximum number of linearly
# independent rows is the same as the maximum number of linearly independent
# columns.
def portfolio(self, port):
    if port != 80:
       return port
    else:
      print(port, 'ftp')
n=1
m=80
max(n, m)
portfolio(3, port=80)


# Because the row rank, the column rank, and the rank of A are all the
# same, we have
# rank(A) = dim(V(A)),
# (3.87)
# rank(A T ) = rank(A), (3.88)
# dim(V(A T )) = dim(V(A)). (3.89)
# (Note, of course, that in general V(A T ) = V(A); the orders of the vector 
# spaces are possibly diﬀerent.)      
rank(3, r=A)      

def dim(self, v, at, a):
    if v is None:
      return v
    else:
      print(v * v)
    if at is None:
      return at
    else:
      print(at * at / at)
    if a is False:
      return -0
    else:
      print(a)
      
dim(1, v=0, at=2, a=1)      

      
