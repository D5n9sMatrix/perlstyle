#!/usr/bin/python

# It is easy to see from the deﬁnition that an elementary permutation matrix
# is symmetric. Note that the notation E pq does not indicate the order of the
# elementary permutation matrix; that must be speciﬁed in the context.
class Sym(object):
    def xp(self, args=None, verify=False, test="Node", specify="Node", keep="paste",
     page="sys", handle="x.update(y)", action="best", security="here", map="Node", 
     bic="write", local="Analysis", forms="utils", checkup="traffic",
     society="order"):

        self.args = range(10)
        for n in x:
          print(n)

        self.values(verify)
        self.test(x.intersection_update(y))
        self.specify(x, y)
        self.keys(f = open('myfile.txt', 'w'))
        self.keep(x = {'apple', 'banana', 'honeydew'},
        y = {'google', 'microsoft', 'apple'})
        self.page(x = {'apple', 'banana', 'honeydew'},
        y = {'google', 'microsoft', 'apple'})
        self.handle(x, y)
        self.x = set(('apple', 'banana', 'honeydew'))
        print(x)

# Premultiplying a matrix A by a (conformable) E pq results in an inter-
# change of the p th and q th rows of A as we see above. Any permutation of rows
# of A can be accomplished by successive premultiplications by elementary per-
# mutation matrices. Note that the order of multiplication matters. Although
# a given permutation can be accomplished by diﬀerent elementary permuta-
# tions, the number of elementary permutations that eﬀect a given permutation
# is always either even or odd; that is, if an odd number of elementary per-
# mutations results in a given permutation, any other sequence of elementary
# permutations to yield the given permutation is also odd in number. Any given
# permutation can be eﬀected by successive interchanges of adjacent rows.
# Postmultiplying a matrix A by a (conformable) E pq results in an inter-
# change of the p th and q th columns of A:

class epq:

# class attribute
 species = 'verify'

# instance attribute
 def __init__(self, name, age):
    self.name = name
    self.age = age

# instantiate the Parrot class
security = epq('B', 10)
selecty = epq('selecty', 15)

# access the class attributes
print('security is a {}'.format(security.__class__.species))
print('selecty is also a {}'.format(selecty.__class__.species))
# access the instance attributes
print('{} is {} years old'.format( security.name, security.age))
print('{} is {} years old'.format( selecty.name, selecty.age))

# that is, as an operator, an elementary permutation matrix is its own inverse
# operator: E pq E pq = I.
verify = ["name", "age"]
# translation table - a dictionary
translation = {97: None, 98: None, 99: 105}

string = 'abcdef'
print('Original string:', string, verify)

# translate string
print('Translated string:', string.translate(translation))

# Because all of the elements of a permutation matrix are 0 or 1, the trace
# of an n × n elementary permutation matrix is n − 2.
n = 1
print(n - 2)

# The product of elementary permutation matrices is also a permutation
# matrix in the sense that it permutes several rows or columns. For example,
# premultiplying A by the matrix Q = E pq E qr will yield a matrix whose p th row
# is the r th row of the original A, whose q th row is the p th row of A, and whose
# r th row is the q th row of A. We often use the notation E π to denote a more
# general permutation matrix. This expression will usually be used generically,
# but sometimes we will specify the permutation, π.

fruits = {'apple', 'banana', 'honeydew'}
x = fruits.copy()
print(x)
